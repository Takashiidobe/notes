---
title: Memory Management
date created: Sunday, July 27th 2025, 4:00:14 pm
date modified: Sunday, July 27th 2025, 4:24:48 pm
---

# Memory Management

Prev: [deadlocks](deadlocks.md)
Next: [inputoutput](inputoutput.md)

# Chapter 4: Memory Management — Modern Operating Systems (2nd Edition)

## Problems

1. **A computer system has enough room to hold four programs in its main memory. These programs are idle waiting for I/O half the time. What fraction of the CPU time is wasted?**

2. **In Fig. 4-21 we saw an example of how multiple jobs can run in parallel and finish faster than if they had run sequentially. Suppose that two jobs, each of which needs 10 minutes of CPU time, start simultaneously. How long will the last one take to complete if they run sequentially? How long if they run in parallel? Assume 50% I/O wait.**

3. **A swapping system eliminates holes by compaction. Assuming a random distribution of many holes and many data segments and a time to read or write a 32-bit memory word of 10 nsec, about how long does it take to compact 128 MB? For simplicity, assume that word 0 is part of a hole and that the highest word in memory contains valid data.**

4. **In this problem you are to compare the storage needed to keep track of free memory using a bitmap versus using a linked list. The 128-MB memory is allocated in units of $n$ bytes. For the linked list, assume that memory consists of an alternating sequence of segments and holes, each 64 KB. Also assume that each node in the linked list needs a 32-bit memory address, a 16-bit length, and a 16-bit next-node field. How many bytes of storage is required for each method? Which one is better?**

5. **Consider a swapping system in which memory consists of the following hole sizes in memory order: 10 KB, 4 KB, 20 KB, 18 KB, 7 KB, 9 KB, 12 KB, and 15 KB. Which hole is taken for successive segment requests of**

- (a) 12 KB  
- (b) 10 KB  
- (c) 9 KB  

**for first fit? Now repeat the question for best fit, worst fit, and next fit.**

6. **What is the difference between a physical address and a virtual address?**

7. **For each of the following decimal virtual addresses, compute the virtual page number and offset for a 4-KB page and for an 8-KB page: 20000, 32768, 60000.**

8. **Using the page table of Fig. 4-10, give the physical address corresponding to each of the following virtual addresses:**

- (a) 20  
- (b) 4100  
- (c) 8300  

9. **The Intel 8086 processor does not support virtual memory. Nevertheless, some companies previously sold systems that contained an unmodified 8086 CPU and did paging. Make an educated guess as to how they did it. _Hint_: Think about the logical location of the MMU.**

10. **The amount of disk space that must be available for page storage is related to the maximum number of processes, $n$, the number of bytes in the virtual address space, $v$, and the number of bytes of RAM, $r$. Give an expression for the worst case disk space requirements. How realistic is this amount?**

11. **If an instruction takes 10 nsec and a page fault takes an additional $n$ nsec, give a formula for the effective instruction time if page faults occur every $k$ instructions.**

12. **A machine has a 32-bit address space and an 8-KB page. The page table is entirely in hardware, with one 32-bit word per entry. When a process starts, the page table is copied to the hardware from memory, at one word every 100 nsec. If each process runs for 100 msec (including the time to load the page table), what fraction of the CPU time is devoted to loading the page tables?**

13. **A computer with a 32-bit address uses a two-level page table. Virtual addresses are split into a 9-bit top-level page table field, an 11-bit second-level page table field, and an offset. How large are the page tables and how many are there in the address space?**

14. **Suppose that a 32-bit virtual address is broken up into four fields, $a$, $b$, $c$, and $d$. The first three are used for a three-level page table system. The fourth field, $d$, is the offset. Does the number of pages depend on the sizes of all four fields? If not, which ones matter and which ones do not?**

15. **A computer has 32-bit virtual addresses and 4-KB pages. The program and data together fit in the lowest page (0–4095). The stack fits in the highest page. How many entries are needed in the page table if traditional (one-level) paging is used? How many page table entries are needed for two-level paging, with 10 bits in each part?**

16. **Below is an execution trace of a program fragment for a computer with 512-byte pages. The program is located at address 1020, and its stack pointer is at 8192 (the stack grows toward 0). Give the page reference string generated by this program. Each instruction occupies 4 bytes (1 word) including immediate constants. Both instruction and data references count in the reference string.**

```
Load word 6144 into register 0  
Push register 0 onto the stack  
Call a procedure at 5120, stacking the return address  
Subtract the immediate constant 16 from the stack pointer  
Compare the actual parameter to the immediate constant 4  
Jump if equal to 5152  
```

17. **A computer whose processes have 1024 pages in their address spaces keeps its page tables in memory. The overhead required for reading a word from the page table is 5 nsec. To reduce this overhead, the computer has a TLB, which holds 32 (virtual page, physical page frame) pairs, and can do a look up in 1 nsec. What hit rate is needed to reduce the mean overhead to 2 nsec?**

18. **The TLB on the VAX does not contain an R bit. Why?**

19. **How can the associative memory device needed for a TLB be implemented in hardware, and what are the implications of such a design for expandability?**

20. **A machine has 48-bit virtual addresses and 32-bit physical addresses. Pages are 8 KB. How many entries are needed for the page table?**

21. **A computer with an 8-KB page, a 256-KB main memory, and a 64-GB virtual address space uses an inverted page table to implement its virtual memory. How big should the hash table be to ensure a mean hash chain length of less than 1? Assume that the hash table size is a power of two.**

22. **A student in a compiler design course proposes to the professor a project of writing a compiler that will produce a list of page references that can be used to implement the optimal page replacement algorithm. Is this possible? Why or why not? Is there anything that could be done to improve paging efficiency at run time?**

23. **If FIFO page replacement is used with four page frames and eight pages, how many page faults will occur with the reference string 0172327103 if the four frames are initially empty? Now repeat this problem for LRU.**

24. **Consider the page sequence of Fig. 4-16(b). Suppose that the R bits for the pages B and C are 11011011, respectively. Which page will second chance remove?**

25. **A small computer has four page frames. At the first clock tick, the R bits are 0111 (page 0 is 0, the rest are 1). At subsequent clock ticks, the values are 1011, 1010, 0010, 1010, 1100, and 0001. If the aging algorithm is used with an 8-bit counter, give the values of the four counters after the last tick.**

26. **Suppose that $\tau = 400$ in Fig. 4-21. Which page will be removed?**

27. **In the WSClock algorithm of Fig. 4-22(c), the hand points to a page with $R = 0$. If $\tau = 400$, will this page be removed? What about if $\tau = 1000$?**

28. **How long does it take to load a 64-KB program from a disk whose average seek time is 10 msec, whose rotation time is 10 msec, and whose tracks hold 32 KB**

- (a) for a 2-KB page size?  
- (b) for a 4-KB page size?  

**The pages are spread randomly around the disk and the number of cylinders is so large that the chance of two pages being on the same cylinder is negligible.**

29. **A computer has four page frames. The time of loading, time of last access, and the R and M bits for each page are as shown below (the times are in clock ticks):**

| Page | Loaded | Last Ref. | R | M |
|------|--------|-----------|---|---|
| 0    | 126    | 280       | 1 | 0 |
| 1    | 230    | 265       | 0 | 1 |
| 2    | 140    | 270       | 0 | 0 |
| 3    | 110    | 285       | 1 | 1 |

**(a) Which page will NRU replace?**  
**(b) Which page will FIFO replace?**  
**(c) Which page will LRU replace?**  
**(d) Which page will second chance replace?**

30. **One of the first timesharing machines, the PDP-1, had a memory of 4K 18-bit words. It held one process at a time in memory. When the scheduler decided to run another process, the process in memory was written to a paging drum, with 4K 18-bit words around the circumference of the drum. The drum could start writing (or reading) at any word, rather than only at word 0. Why do you suppose this drum was chosen?**

31. **A computer provides each process with 65,536 bytes of address space divided into pages of 4096 bytes. A particular program has a text size of 32,768 bytes, a data size of 16,386 bytes, and a stack size of 15,870 bytes. Will this program fit in the address space? If the page size were 512 bytes, would it fit? Remember that a page may not contain parts of two different segments.**

32. **Can a page be in two working sets at the same time? Explain.**

33. **If a page is shared between two processes, is it possible that the page is read-only for one process and read-write for the other? Why or why not?**

34. **It has been observed that the number of instructions executed between page faults is directly proportional to the number of page frames allocated to a program. If the available memory is doubled, the mean interval between page faults is also doubled. Suppose that a normal instruction takes 1 microsec, but if a page fault occurs, it takes 2001 μsec (i.e., 2 msec to handle the fault). If a program takes 60 sec to run, during which time it gets 15,000 page faults, how long would it take to run if twice as much memory were available?**

35. **A group of operating system designers for the Frugal Computer Company are thinking about ways of reducing the amount of backing store needed in their new operating system. The head guru has just suggested not bothering to save the program text in the swap area at all, but just page it in directly from the binary file whenever it is needed. Under what conditions, if any, does this idea work for the program text? Under what conditions, if any, does it work for the data?**

36. **A machine language instruction to load a 32-bit word into a register contains the 32-bit address of the word to be loaded. What is the maximum number of page faults this instruction can cause?**

37. **Explain the difference between internal fragmentation and external fragmentation. Which one occurs in paging systems? Which one occurs in systems using pure segmentation?**

38. **When segmentation and paging are both being used, as in MULTICS, first the segment descriptor must be looked up, then the page descriptor. Does the TLB also work this way, with two levels of lookup?**

39. **Plot a histogram and calculate the mean and median of the sizes of executable binary files on a computer to which you have access. On a Windows system, look at all `.exe` and `.dll` files; on a UNIX system look at all executable files in `/bin`, `/usr/bin`, and `/local/bin` that are not scripts (or use the `file` utility to find all executables). Determine the optimal page size for this computer just considering the code (not data). Consider internal fragmentation and average page table size, making some reasonable assumption about the size of a page table entry. Assume that all programs are equally likely to be run and thus should be weighted equally.**

40. **Small programs for MS-DOS can be compiled as `.COM` files. These files are always loaded at address `0x100` in a single memory segment that is used for code, data, and stack. Instructions that transfer control of execution, such as `JMP` and `CALL`, or that access static data from fixed addresses have the addresses compiled into the object code. Write a program that can relocate such a program file to run starting at an arbitrary address. Your program must scan through code looking for object codes for instructions that refer to fixed memory addresses, then modify those addresses that point to memory locations within the range to be relocated. You can find the object codes in an assembly language programming text. Note that doing this perfectly without additional information is, in general, an impossible task, because some data words may have values that mimic instruction object codes.**

41. **Write a program that simulates a paging system. At the start of the program, the user should be asked to choose a page replacement algorithm, choosing from FIFO, LRU, and at least one other. On each cycle, read the number of the referenced page from a file. Generate a listing similar to Fig. 4-25, except rotated 90 degrees so that each new page reference increases the length of the output file by one line.**

42. **Write a program that models the distance string algorithm described in the text. The input to the program is a list of page references (contained in a file), plus the number of page frames of physical memory available. If possible, use trace data from real programs instead of randomly-generated page references. The program should maintain the stack of pages, analogous to Fig. 4-25. At each page fault, a procedure should be called to choose a replacement page. When the run is completed, the program should plot the distance string, analogous to Fig. 4-26. Make multiple runs for different values of the memory size and see what conclusions you can draw.**


Prev: [deadlocks](deadlocks.md)
Next: [inputoutput](inputoutput.md)
